import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar

buildscript {
    dependencies {
        classpath "net.neoforged:JarJarMetadata:0.4.1"
        classpath "com.github.johnrengelman:shadow:8.1.1"
    }
}

plugins {
    id "maven-publish"
}

group = mod_group_id
version = mod_version

tasks.replace("jar", ShadowJar)

tasks.register("modImplJar", ShadowJar) {
    archiveBaseName = "ElecLoaderMod"

    mergeServiceFiles()
    transform(ManifestMergeTransformer)
    manifest {
        attributes(["Implementation-Title": "modImpl"])
    }
}

tasks.register("makeJiJMeta", JijFile) {
    dependsOn(tasks.modImplJar)
    input = files(tasks.modImplJar.outputs)
}

tasks.register("shadowWorkAround", Jar) {
    archiveBaseName = "ShadowWorkaround"
    into("META-INF/jarjar") {
        from(tasks.makeJiJMeta.outputs)
        from(tasks.modImplJar.outputs)
    }
}

jar {
    mergeServiceFiles()
//    transform(ManifestMergeTransformer)
    manifest { //TODO: ManifestMerger produces a perfectly valid (byte-for-byte identical) MF file, but somehow Forge shits itself on it
        attributes(["FMLModType": "LANGPROVIDER", "Implementation-Version": version])
    }
    manifest {
        attributes(["Implementation-Title": "all"])
    }

    from(files(tasks.shadowWorkAround.outputs))
}

tasks.withType(GenerateModuleMetadata.class).configureEach(meta -> meta.setEnabled(false))

subprojects {
    
    if (project.modProject) {
        afterEvaluate {
            rootProject.jar {
                from jar.outputs
            }
            if (project.tasks.findByName("modImplJar") != null) {
                rootProject.tasks.modImplJar.from(project.tasks.modImplJar.outputs)
            }
            if (!project.hasModLoader) { //Common project
                rootProject.publishing.publications.modPublication {
                    artifact sourcesJar
                    artifact javadocJar
                }
            }
        }
    }
    if (!project.hasModLoader) {
        return
    }
    modloader {
        addCommonDependency = false
    }
}

publishing {
    repositories {
        maven {
            url "file://" + System.getenv("local_maven")
        }
    }
    publications {
        create("modPublication", MavenPublication) {
            from components.java
        }
    }
}

///////////////////////////////////////////////////////////////////////

import com.github.jengelman.gradle.plugins.shadow.transformers.TransformerContext
import net.neoforged.jarjar.metadata.*
import org.apache.maven.artifact.versioning.DefaultArtifactVersion
import org.apache.maven.artifact.versioning.VersionRange
import org.apache.tools.zip.ZipEntry
import org.apache.tools.zip.ZipOutputStream

import java.nio.file.Files
import java.nio.file.StandardOpenOption
import java.util.stream.Collectors

import static java.util.jar.JarFile.MANIFEST_NAME

abstract class JijFile extends DefaultTask {

    JijFile() {
        jsonFile.convention(project.layout.buildDirectory.file("jij/metadata.json"))
    }

    @InputFiles
    abstract ConfigurableFileCollection getInput();

    @OutputFile
    abstract RegularFileProperty getJsonFile();

    @TaskAction
    void createFile() {
        File mdjp = getJsonFile().asFile.get()
        try {
            mdjp.parentFile.mkdirs()
            Files.deleteIfExists(mdjp.toPath())
            Files.write(mdjp.toPath(), MetadataIOHandler.toLines(new Metadata(input.files.stream().map {
                var fn = it.name.split("-")
                return new ContainedJarMetadata(new ContainedJarIdentifier(getProject().group.toString(), fn[0]), new ContainedVersion(VersionRange.createFromVersionSpec("[" + project.version + ",)"), new DefaultArtifactVersion(project.version.toString())), "META-INF/jarjar/" + it.name, false)
            }.collect(Collectors.toList()))), StandardOpenOption.CREATE_NEW, StandardOpenOption.WRITE)
        } catch(Exception e) {
            throw new RuntimeException(e)
        }
    }

}

class ManifestMergeTransformer implements com.github.jengelman.gradle.plugins.shadow.transformers.Transformer {

    private java.util.jar.Manifest manifest = new java.util.jar.Manifest()

    @Override
    boolean canTransformResource(FileTreeElement element) {
        MANIFEST_NAME.equalsIgnoreCase(element.relativePath.pathString)
    }

    @Override
    void transform(TransformerContext context) {
        try (InputStream is = context.is) {
            java.util.jar.Manifest toMerge = new java.util.jar.Manifest(is)
            for (Map.Entry<String, java.util.jar.Attributes> entry : manifest.getEntries().entrySet()) {
                var other = toMerge.getEntries().get(entry.getKey())
                var puts = entry.getValue()
                if (other != null) {
                    puts = other.putAll(puts)
                }
                manifest.getEntries().put(entry.getKey(), puts)
            }
            toMerge.mainAttributes.putAll(manifest.mainAttributes)
            manifest = toMerge
        }
    }

    @Override
    boolean hasTransformedResource() {
        return true
    }

    @Override
    void modifyOutputStream(ZipOutputStream os, boolean preserveFileTimestamps) {
        ZipEntry entry = new ZipEntry(MANIFEST_NAME)
        entry.time = TransformerContext.getEntryTimestamp(preserveFileTimestamps, entry.time)
        os.putNextEntry(entry)
        if (manifest != null) {
            ByteArrayOutputStream manifestContents = new ByteArrayOutputStream()
            manifest.write(manifestContents)
            os.write(manifestContents.toByteArray())
        }
    }

}