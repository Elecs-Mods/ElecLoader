import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar
import net.neoforged.jarjar.metadata.*
import org.apache.maven.artifact.versioning.DefaultArtifactVersion
import org.apache.maven.artifact.versioning.VersionRange

import java.nio.file.Files
import java.nio.file.StandardOpenOption
import java.util.stream.Collectors

buildscript {
    dependencies {
        classpath "net.neoforged:JarJarMetadata:0.4.1"
        classpath "com.gradleup.shadow:shadow-gradle-plugin:9.2.2"
    }
}

plugins {
    id "maven-publish"
}

group = mod_group_id
version = mod_version

tasks.replace("jar", ShadowJar)

tasks.register("modImplJar", ShadowJar) {
    destinationDirectory = project.layout.buildDirectory.dir("subLibs")
    archiveBaseName = "ElecLoaderMod"

    duplicatesStrategy DuplicatesStrategy.INCLUDE
    mergeServiceFiles()
    manifest {
        attributes(["Implementation-Title": "modImpl"])
    }
}

tasks.register("makeJiJMeta", JijFile) {
    dependsOn(tasks.modImplJar)
    input = files(tasks.modImplJar.outputs)
}

tasks.register("shadowWorkAround", Jar) {
    destinationDirectory = project.layout.buildDirectory.dir("subLibs")
    archiveBaseName = "ShadowWorkaround"
    into("META-INF/jarjar") {
        from(tasks.makeJiJMeta.outputs)
        from(tasks.modImplJar.outputs)
    }
}

tasks.register("devJar", ShadowJar) {
    archiveClassifier = "dev"
}
tasks.assemble.dependsOn devJar

[jar, devJar].each { j ->
    j.duplicatesStrategy DuplicatesStrategy.INCLUDE
    j.mergeServiceFiles()
    j.manifest {
        attributes(["Implementation-Title": "all"])
    }

    j.includedDependencies.from tasks.shadowWorkAround.outputs
}

tasks.withType(GenerateModuleMetadata.class).configureEach(meta -> meta.setEnabled(false))

subprojects {
    
    if (project.modProject) {
        afterEvaluate {
            rootProject.jar {
                includedDependencies.from remappedJar.outputs
                mergeManifest(manifest, jar.manifest)
            }
            rootProject.devJar {
                includedDependencies.from devJar.outputs
                mergeManifest(manifest, devJar.manifest)
            }
            if (project.tasks.findByName("modImplJar") != null) {
                rootProject.tasks.modImplJar.includedDependencies.from(project.tasks.modImplJar.outputs)
                mergeManifest(rootProject.tasks.modImplJar.manifest, project.tasks.modImplJar.manifest)
            }
            if (!project.hasModLoader) { //Common project
                rootProject.publishing.publications.modPublication {
                    artifact sourcesJar
                    artifact javadocJar
                    artifact jar
                }
            }
        }
    }
    if (!project.hasModLoader) {
        return
    }

    sourceSets {

        modRun {
            java.setSrcDirs([project.layout.buildDirectory.get().dir("tmp/modRunSrc").asFile])
            resources.setSrcDirs([])
            runtimeClasspath += rootProject.tasks.devJar.outputs.files
        }

    }

    modloader {
        addCommonDependency = false
        runtimeSource = sourceSets.modRun
    }

    mkdir(compileModRunJava.destinationDirectory)
    mkdir(processModRunResources.getDestinationDir())
    tasks.modRunClasses.dependsOn(rootProject.tasks.devJar)

    dependencies {
        compileOnly(project(":repackaged"))
        compileOnly(project(":common"))
    }

    configurations {
        modRunRuntimeClasspath.extendsFrom runtimeClasspath
    }

}

publishing {
    repositories {
        maven {
            url "file://" + System.getenv("local_maven")
        }
    }
    publications {
        create("modPublication", MavenPublication) {
            artifact jar
            artifact devJar
        }
    }
}

///////////////////////////////////////////////////////////////////////

abstract class JijFile extends DefaultTask {

    JijFile() {
        jsonFile.convention(project.layout.buildDirectory.file("jij/metadata.json"))
    }

    @InputFiles
    abstract ConfigurableFileCollection getInput();

    @OutputFile
    abstract RegularFileProperty getJsonFile();

    @TaskAction
    void createFile() {
        File mdjp = getJsonFile().asFile.get()
        try {
            mdjp.parentFile.mkdirs()
            Files.deleteIfExists(mdjp.toPath())
            Files.write(mdjp.toPath(), MetadataIOHandler.toLines(new Metadata(input.files.stream().map {
                var fn = it.name.split("-")
                return new ContainedJarMetadata(new ContainedJarIdentifier(getProject().group.toString(), fn[0]), new ContainedVersion(VersionRange.createFromVersionSpec("[" + project.version + ",)"), new DefaultArtifactVersion(project.version.toString())), "META-INF/jarjar/" + it.name, false)
            }.collect(Collectors.toList()))), StandardOpenOption.CREATE_NEW, StandardOpenOption.WRITE)
        } catch(Exception e) {
            throw new RuntimeException(e)
        }
    }

}

static void mergeManifest(Manifest main, Manifest child) {
    main.from(child) {
        eachEntry {
            //Ensures original properties take precedence instead of new values
            if (it.getBaseValue() != null) {
                setValue(getBaseValue())
            }
        }
    }
}
