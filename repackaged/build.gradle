import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar
import org.gradle.api.internal.file.copy.CopyAction

buildscript {
    dependencies {
        //Can's add it as plugin, as it's already on classpath from root project,
        //except when trying to use ShadowJar gradle freaks out complaining the class isn't on the classpath...
        classpath "com.github.johnrengelman:shadow:8.1.1"
    }
}

plugins {
    id "java-library"
//    id "com.github.johnrengelman.shadow" version "8.1.1"
    id "org.jetbrains.gradle.plugin.idea-ext" version "1.1.7"
}

group = "nl.elec332.minecraft.repacked"
version = "0"

repositories {
    mavenCentral()
    ivy {
        url "https://github.com/"
        patternLayout {
            artifact "[organisation]/[module]/archive/[revision].[ext]"
        }
        metadataSources {
            artifact()
        }
    }
}

configurations {
    repackagedDeps
    shadowSource
}

afterEvaluate {
    tasks.withType(DownloadGithub).configureEach {
        sourceSets.main.java.srcDir(it.destDir)
    }
}

tasks.register("makeMiniJar", Jar) {
    archiveBaseName = "minijar"
    project.configurations.repackagedDeps.resolve().each {
        from zipTree(it).matching {
            include("net/neoforged/**/*.*")
            include("org/apache/maven/artifact/versioning/**/*.*")
        }
    }
}

dependencies {
    repackagedDeps("net.neoforged:bus:7.2.0") {
        transitive = false
    }
    repackagedDeps("org.apache.maven:maven-artifact:3.8.5") {
        transitive = false
    }
    repackagedDeps("net.neoforged:srgutils:1.0.0") {
        transitive = false
    }
    shadowSource("net.jodah:typetools:0.6.3")
    shadowSource tasks.makeMiniJar.outputs.files
}

tasks.register("makeRepackagedJar", ShadowJar) {
    configurations = [project.configurations.shadowSource]
    exclude("META-INF/maven/")

    enableRelocation true
    relocationPrefix "nl.elec332.minecraft.repackaged"
}

tasks.register("fakeRepackagedClasses", Copy) {
    dependsOn("makeRepackagedJar")
    from zipTree(tasks.makeRepackagedJar.outputs.files.asPath)
    into sourceSets.main.java.destinationDirectory
}

tasks.compileJava.dependsOn "fakeRepackagedClasses"
tasks.jar.enabled false
tasks.javadoc.enabled false
tasks.compileJava.enabled false

//forge: cb38ccd
tasks.register("downloadBusSource", DownloadGithub) {
    dstPackage = "nl.elec332.minecraft.repackaged"
    packageRoot = "net.neoforged.bus"

    fromRepo("neoforged", "Bus", "ea4401c")
    exclude "**/bus-*/**"
}

tasks.register("downloadMavenSource", DownloadGithub) {
    dstPackage = "nl.elec332.minecraft.repackaged"
    packageRoot = "org.apache.maven.artifact.versioning"
    sourcePrefix = "**/maven-artifact"

    fromRepo("apache", "Maven", "3cebbf7")
}

tasks.register("downloadSRGSource", DownloadGithub) {
    dstPackage = "nl.elec332.minecraft.repackaged"
    packageRoot = "net.neoforged.srgutils"

    fromRepo("neoforged", "SRGUtils", "207fb0a")
}

tasks.register("downloadSources") {
    dependsOn("downloadBusSource")
    dependsOn("downloadMavenSource")
    dependsOn("downloadSRGSource")
}

var thisName = name
rootProject.idea.project.settings {
    taskTriggers {
        afterSync thisName + ":downloadSources"
    }
}

///////////////////////////////////////////////////////////////////////

abstract class DownloadGithub extends Copy {

    DownloadGithub() {
        includeEmptyDirs = false
        destDir.convention(project.layout.buildDirectory.dir(sourceName.map {"srcDir_" + it}))
        mainSource.convention("src/main/java")
        sourcePrefix.convention("**")

        into destDir.dir(dstPackage.map {it.replace(".", "/")})

        //Runs after copy task for some reason
//        doFirst {
//            project.file(destDir).deleteDir()
//        }

        eachFile {
            String[] fn = it.getPath().split("src/main/java/")
            assert fn.length == 2
            it.setPath(fn[1])
        }
    }

    @Override
    protected CopyAction createCopyAction() {
        project.file(destDir).deleteDir()
        return super.createCopyAction()
    }

    @Input
    abstract Property<String> getSourceName();

    @Input
    abstract Property<String> getDstPackage();

    @Input
    abstract Property<String> getPackageRoot();

    @Internal // Already output dir in Copy
    abstract DirectoryProperty getDestDir();

    @Input
    abstract Property<String> getMainSource();

    @Input
    abstract Property<String> getSourcePrefix();

    @InputFiles
    Configuration cfg = null

    void fromRepo(String org, String repo, String version) {
        if (cfg != null) {
            throw new RuntimeException()
        }
        if (!sourceName.present) {
            sourceName.set(repo)
        }
        cfg = project.configurations.create(sourceName.get() + "Zip")
        project.dependencies.add(cfg.name, [group: org, name: repo, version: version, ext: "zip"])
        from project.zipTree(cfg.resolve().iterator().next()).matching {
            exclude "**/module-info.java"
            include sourcePrefix.get() + "/" + mainSource.get() + "/" + packageRoot.get().replace(".", "/") + "/**/*.java"
            filter { line ->
                line.replace(packageRoot.get(), dstPackage.map {it + "." + packageRoot.get()}.get())
            }
        }
    }

}
